/* This file is generated by tdr. */
/* No manual modification is permitted. */

/* creation time: Tue Jun  4 14:17:59 2019 */
/* tdr version: 2.7.26, build at 20171102 */

#ifndef TSF4G_TDR_TDR_TLV_H_
#define TSF4G_TDR_TDR_TLV_H_

#include "TdrBuf.h"
#include "TdrError.h"

namespace tsf4g_tdr
{

class TdrTLVUtil
{
    public:
        enum TdrTLVTypeId
        {
            TDR_TYPE_ID_VARINT           = 0,
            TDR_TYPE_ID_1_BYTE           = 1,
            TDR_TYPE_ID_2_BYTE           = 2,
            TDR_TYPE_ID_4_BYTE           = 3,
            TDR_TYPE_ID_8_BYTE           = 4,
            TDR_TYPE_ID_LENGTH_DELIMITED = 5,
        };

        enum TdrTLVMagic
        {
            TDR_TLV_MAGIC_VARINT         = 0xaa,
            TDR_TLV_MAGIC_NOVARINT       = 0x99,
        };

        /* 1byte magic + 4byte msglength */
        static const size_t TLV_MSG_MAGIC_SIZE = 1;

        /* 1byte magic + 4byte msglength */
        static const size_t TLV_MSG_MIN_SIZE = 5;

    public:
        static inline uint32_t makeTag(int id, int type_id)
        {
            return ((id << 4) + type_id);
        }

        static inline int getFieldId(uint32_t tagid)
        {
            return (tagid >> 4);
        }

        static inline int getTypeId(uint32_t tagid)
        {
            return (tagid & 0xf);
        }

        /* get message size, useful in TCP. */
        /*  if unknown yet return 0, if error return -1 */
        static inline int getMsgSize(const char* buffer, size_t size)
        {
            if (NULL == buffer || size < TLV_MSG_MIN_SIZE)
            {
                return 0;
            }

            if ((unsigned char)buffer[0] != TDR_TLV_MAGIC_VARINT &&
                (unsigned char)buffer[0] != TDR_TLV_MAGIC_NOVARINT)
            {
                return -1;
            }
            int iMsgSize = 0;
            tdr_cpp_cast_ntoh32(&iMsgSize, buffer + TLV_MSG_MAGIC_SIZE);

            return iMsgSize;
        }

        static inline TdrError::ErrorType
        skipUnknownFields(TdrReadBuf& srcBuf, int type_id)
        {
            TdrError::ErrorType ret = TdrError::TDR_NO_ERROR;

            switch (type_id)
            {
                case TDR_TYPE_ID_VARINT:
                    {
                        uint64_t tmp = 0;
                        ret = srcBuf.readVarUInt64(tmp);
                        break;
                    }
                case TDR_TYPE_ID_1_BYTE:
                    {
                        ret = srcBuf.skipForward(1);
                        break;
                    }
                case TDR_TYPE_ID_2_BYTE:
                    {
                        ret = srcBuf.skipForward(2);
                        break;
                    }
                case TDR_TYPE_ID_4_BYTE:
                    {
                        ret = srcBuf.skipForward(4);
                        break;
                    }
                case TDR_TYPE_ID_8_BYTE:
                    {
                        ret = srcBuf.skipForward(8);
                        break;
                    }
                case TDR_TYPE_ID_LENGTH_DELIMITED:
                    {
                        uint32_t dwLength = 0;
                        ret = srcBuf.readUInt32(dwLength);
                        if (TdrError::TDR_NO_ERROR != ret)
                        {
                            TSF4G_TDR_DEBUG_TRACE();
                            return ret;
                        }
                        ret = srcBuf.skipForward(dwLength);
                        break;
                    }
                default:
                    {
                        return TdrError::TDR_ERR_UNKNOWN_TYPE_ID;
                    }
            }

            return ret;
        }

    private:
        TdrTLVUtil();
        TdrTLVUtil(const TdrTLVUtil&);
        TdrTLVUtil& operator=(const TdrTLVUtil&);
};

}
#endif
